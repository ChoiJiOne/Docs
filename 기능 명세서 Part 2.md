# [기능 명세서 Part 2 : 명세서란?](https://www.joelonsoftware.com/2000/10/03/painless-functional-specifications-part-2-whats-a-spec/)

이 연재 글은 기술 명세서가 아닌 기능 명세서에 관한 것입니다. 많은 사람들이 이 둘을 혼동합니다. 표준 용어가 정해져 있는지는 모르겠지만, 제가 이 용어들을 사용할 때의 의미는 다음과 같습니다.

- `기능 명세서`: 제품이 사용자 관점에서 어떻게 동작하는지를 설명합니다. 구현 방식에는 관심이 없습니다. 기능에 대해 이야기하며, 화면, 메뉴, 대화 상자 등을 명시합니다.
- `기술 명세서`: 프로그램의 내부 구현을 설명합니다. 데이터 구조, 관계형 데이터베이스 모델, 사용할 프로그래밍 언어나 도구, 알고리즘 등에 대해 이야기합니다.

제품을 설계할 때, 내부 구조보다 가장 중요한 것은 제품의 동작 방식을 명확히 정의하는 것입니다. 어떤 화면이 있고, 그것들이 어떻게 동작하며, 무엇을 할 수 있는지 등을 결정하는 것이 우선입니다. 그 다음에 비로소 그 구현 방법을 고민해야 합니다. 제품이 무엇을 할 것인지도 정하지 않은 채 어떤 프로그래밍 언어를 쓸지를 두고 논쟁하는 것은 아무런 의미가 없습니다.
이 연재에서는 기능 명세서에 대해서만 다룰 것입니다.

제가 짧은 예시 명세서를 하나 작성해두었습니다. 좋은 기능 명세서가 어떤 모습인지 감을 잡을 수 있을 것입니다.
다음 단계로 넘어가기 전에, 그 [예시 명세서](https://www.joelonsoftware.com/whattimeisit/)를 꼭 읽어보시기 바랍니다.

읽으셨나요?

아니요, 아직 안 읽으셨군요. 지금 가서 읽고 오세요. 그 다음에, 좋은 명세서에 무엇을 포함해야 하고, 무엇은 포함하지 말아야 하는지에 대해 더 이야기해봅시다. 저는 여기서 기다리고 있겠습니다. 감사합니다.

(조용히 기다리는 중…)

좋습니다, 돌아오셨군요.

다음은 제가 모든 명세서에 반드시 포함하는 항목들입니다.

## 면책 조항.

자기 방어를 위한 것입니다. “이 명세서는 아직 완성되지 않았습니다” 같은 문단을 적어두면, 사람들이 사무실에 찾아와 당신을 몰아세우지 않습니다. 시간이 지나 명세서가 거의 완성되었을 때는 그 문구를 “이 명세서는 내가 아는 한 완전합니다. 만약 빠진 것이 있다면 알려주세요.”로 바꾸면 됩니다. 이와 관련하여, 모든 명세서에는 다음이 필요합니다:

## 작성자. 한 명의 작성자.

일부 회사는 명세서를 팀이 함께 작성해야 한다고 생각합니다. 단체로 글을 써본 적이 있다면 그것만큼 고통스러운 일도 없다는 걸 아실 겁니다. 그런 집단 글쓰기는 대형 컨설팅 회사에서 갓 하버드를 졸업한 신입들이 엄청난 수임료를 정당화하기 위해 하는 바쁜 척 작업에 맡기십시오. 명세서는 반드시 한 사람이 소유하고 작성해야 합니다. 제품이 크다면 영역별로 나누고, 각 영역을 다른 사람에게 맡겨 개별 명세서를 작성하도록 하십시오.
일부 회사는 작성자가 이름을 명세서에 올리는 것을 자만하거나 “협업 정신에 어긋난다”고 여깁니다. 말도 안 됩니다. 사람은 자신이 명시한 것에 대해 책임과 소유권을 가져야 합니다. 명세서에 문제가 생겼을 때, 그것을 고칠 책임이 있는 사람의 이름이 문서에 명확히 기재되어 있어야 합니다.

## 시나리오.

제품을 설계할 때는 사람들이 어떻게 사용할지를 실제로 상상할 수 있는 현실적인 시나리오가 필요합니다. 그렇지 않으면 현실 사용 사례와 동떨어진 제품이 탄생하게 됩니다(CueCat처럼). 제품의 대상 사용자를 선정한 뒤, 각 사용자군에서 전형적인 가상의 사용자를 설정하고, 그들이 제품을 어떻게 사용할지를 구체적으로 상상해보십시오.
UI 설계에 대해 쓴 제 책 9장에서 가상의 사용자와 시나리오를 만드는 법에 대해 설명했으며, 명세서에는 이러한 내용들을 이곳에 넣어야 합니다. 시나리오가 생생하고 현실적일수록, 실제 혹은 가상의 사용자에게 적합한 제품을 설계할 가능성이 높아집니다. 저는 그래서 일부러 많은 세부 사항을 덧붙입니다.

## 회피 목표 (Nongoals).

팀으로 제품을 만들다 보면, 누구나 자신만의 ‘꼭 있어야 한다고 생각하는’ 기능을 제안합니다. 그러나 그것들을 전부 포함하려고 하면 시간은 무한히 걸리고 비용은 감당할 수 없게 됩니다. 따라서 명세서에 ‘하지 않을 일’을 명시한 비목표 섹션이 필요합니다.
예:

“텔레파시 기반 사용자 인터페이스는 포함하지 않음.”

“이번 릴리스에서는 성능에 신경 쓰지 않음. 동작만 하면 됨. 성능 최적화는 2.0에서 시간 나면 고려.”
이런 비목표들은 논쟁을 불러올 수 있지만, 초기 단계에서 공개적으로 정리하는 것이 중요합니다. George Sr.의 말처럼, “안 해, 끝.”

## 개요.

명세서의 목차와 같은 역할을 합니다. 간단한 플로우차트일 수도 있고, 방대한 아키텍처 개요일 수도 있습니다. 누구나 이 부분을 읽고 전체 그림을 파악한 다음 세부 사항을 살펴보게 됩니다.

## 세부 사항, 세부 사항, 또 세부 사항.

이제 진짜 상세한 내용으로 들어갑니다. 대부분의 사람들은 이 부분을 대충 훑어보다가 필요한 게 생겼을 때만 다시 찾아봅니다.
웹 기반 서비스를 설계할 때 좋은 방식은 모든 화면에 고유한 이름을 붙이고, 그 화면 하나하나를 전용 챕터로 나누어 매우 자세히 설명하는 것입니다.

기능 명세서에서 세부 사항은 가장 중요합니다.
샘플 명세서에서 로그인 페이지의 에러 처리 사례를 지나치게 자세히 설명한 부분을 보셨을 겁니다.

이메일 주소가 잘못된 경우는?

비밀번호가 틀린 경우는?
이런 모든 상황은 실제로 작성되어야 할 코드에 해당합니다. 하지만 더 중요한 것은, 이러한 상황들에 대해 반드시 누군가 정책을 결정해야 한다는 것입니다. 결정되지 않으면 코드를 쓸 수 없습니다. 명세서는 그 결정을 문서화해야 합니다.

## 미해결 이슈 (Open Issues).

초안 명세서에 미해결 이슈가 있어도 괜찮습니다. 저는 항상 초안을 쓸 때 미해결 이슈가 많고, 그것들을 따로 검색 가능한 스타일로 표시하고, 가능하다면 그 대안도 정리해둡니다.
그러나 프로그래머들이 작업을 시작할 시점까지는 이 이슈들이 모두 해결되어 있어야 합니다.
“일단 쉬운 것부터 시작하고 미해결된 건 나중에 하자”는 생각은 최악의 아이디어입니다.
프로그래머들이 구현하면서 생기는 새로운 문제만으로도 충분히 골치 아픈데, 미리 알고도 미뤄둔 문제까지 함께 떠안게 되는 셈입니다. 게다가 사소하지 않은 문제일수록 해결 방식이 코드 구조에 큰 영향을 미치게 됩니다.

## 부가 메모 (Side notes).

명세서를 작성할 때는 다양한 독자층을 항상 염두에 두어야 합니다. 예를 들면 프로그래머, 테스터, 마케팅, 기술 문서 작성자 등입니다. 명세서를 쓰다 보면 이들 중 특정 그룹에게만 유용한 정보가 떠오를 수 있습니다.
예를 들어, 저는 프로그래머에게 전하는 메시지, 즉 기술적 구현 세부사항을 **"Technical Notes"**로 표시합니다. 마케팅 팀은 이런 내용을 무시하지만, 프로그래머들은 이런 메모를 탐독합니다.
저의 명세서에는 자주 “Testing Notes”, “Marketing Notes”, “Documentation Notes” 같은 항목이 가득 들어 있습니다.

## 명세서는 살아 있어야 합니다.

일부 개발팀은 폭포수(waterfall) 사고방식을 따릅니다.
“우리는 프로그램을 한 번에 모두 설계하고, 명세서를 작성해서 출력한 뒤, 그것을 프로그래머에게 넘기고 퇴근할 거야.”
이런 사고방식에 대해 제가 할 말은 단 하나입니다:

“하하하하하하하하하!”

이런 방식 때문에 명세서는 평판이 나쁜 것입니다. 많은 사람들이 저에게 이렇게 말했습니다.
“명세서는 쓸모가 없어요. 아무도 따르지 않고, 항상 오래됐고, 실제 제품을 반영하지 않잖아요.”

실례지만, 당신네 명세서가 오래됐고 실제 제품을 반영하지 않는 것일 뿐입니다.
제 명세서는 자주 업데이트됩니다. 제품 개발이 진행되고 새로운 결정이 내려질 때마다 명세서도 함께 갱신됩니다. 명세서는 항상 우리가 제품이 어떻게 동작해야 하는지를 공동으로 이해한 최신 상태를 반영합니다. 명세서는 기능 구현이 모두 끝난 시점(테스트 및 디버깅은 아직 남아 있음)에야 비로소 고정됩니다.

팀원들이 더 편하게 사용할 수 있도록 저는 명세서를 매일 새로 배포하지는 않습니다.
대신, 항상 최신 버전의 명세서를 서버에 올려두고, 팀원들이 참고할 수 있도록 합니다.
그리고 주요 마일스톤 시점에는 명세서를 출력하되, **변경된 부분에 수정 표시(revision marks)**를 남깁니다.
그래야 팀원들이 문서를 처음부터 끝까지 다시 읽을 필요 없이, 수정된 부분만 빠르게 확인할 수 있습니다.